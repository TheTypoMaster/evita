// Copyright (c) 1996-2014 Project Vogue. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "evita/text/undo_stack.h"

#include "base/logging.h"
#include "evita/text/buffer.h"
#include "evita/text/undo_step.h"

namespace text {

UndoStack::UndoStack(Buffer* pBuffer)
    : m_eState(State_Log),
      m_pBuffer(pBuffer),
      m_pFirst(nullptr),
      m_pLast(nullptr),
      m_pRedo(nullptr),
      m_pUndo(nullptr) {
  m_pBuffer->AddObserver(this);
}

UndoStack::~UndoStack() {
  Empty();
}

void UndoStack::addUndoStep(UndoStep* pUndoStep) {
  pUndoStep->m_pPrev = m_pLast;

  if (m_pLast)
    m_pLast->m_pNext = pUndoStep;

  m_pLast = pUndoStep;

  if (!m_pFirst)
    m_pFirst = pUndoStep;
}

void UndoStack::delUndoStep(UndoStep* pUndoStep) {
  auto const pNext = pUndoStep->m_pNext;
  auto const pPrev = pUndoStep->m_pPrev;

  if (!pNext)
    m_pLast = pPrev;
  else
    pNext->m_pPrev = pPrev;

  if (!pPrev)
    m_pFirst = pNext;
  else
    pPrev->m_pNext = pNext;

  delete pUndoStep;
}

bool UndoStack::CanRedo() const {
  return m_pUndo != m_pRedo;
}

bool UndoStack::CanUndo() const {
  switch (m_eState) {
    case State_Log:
      return m_pLast;
    case State_Redo:
      return true;
    case State_Undo:
      return m_pUndo;
    default:
      return false;
  }
}

void UndoStack::CheckPoint() {
  switch (m_eState) {
    case State_Disabled:
      return;

    case State_Undo:
      break;

    case State_Redo:
      if (m_pRedo) {
        // Truncate executed redo logs
        // discarc m_pRedo->m_pNext ... m_pLast
        auto pRunner = m_pRedo->m_pNext;
        while (pRunner) {
          auto const pNext = pRunner->m_pNext;
          delete pRunner;
          pRunner = pNext;
        }
        m_pRedo->m_pNext = nullptr;
        m_pLast = m_pRedo;
      }
      break;
  }
  m_pRedo = nullptr;
  m_eState = State_Log;
}

void UndoStack::Empty() {
  while (m_pUndo){
    auto const next = m_pUndo->m_pNext;
    delete m_pUndo;
    m_pUndo = next;
  }

  while (m_pRedo){
    auto const next = m_pRedo->m_pNext;
    delete m_pRedo;
    m_pRedo = next;
  }

  m_eState = State_Log;
  m_pFirst = nullptr;
  m_pLast = nullptr;
  m_pRedo = nullptr;
  m_pUndo = nullptr;
}

void UndoStack::BeginUndoGroup(const base::string16& name) {
  if (m_eState == State_Disabled)
    return;

  if (m_eState == State_Log && m_pLast &&
      m_pLast->is<EndUndoStep>()) {
    auto const pLast = m_pLast->as<EndUndoStep>();
    if (pLast->CanMerge(name)) {
      // If the last UndoStep is generated by same operation, we merge
      // the last UndoStep and new UndoStep.
      delUndoStep(m_pLast);
      return;
    }
  }

  BeginUndoStep* pUndoStep = new BeginUndoStep(name);
  addUndoStep(pUndoStep);
}

void UndoStack::PushDeleteText(Posn lStart, Posn lEnd) {
  auto const cwch = lEnd - lStart;
  if (cwch <= 0)
    return;

  if (State_Disabled == m_eState)
    return;

  if (m_pLast && m_pLast->is<DeleteUndoStep>()) {
    auto const pLast = m_pLast->as<DeleteUndoStep>();
    if (pLast->Merge(this, lStart, lEnd)) {
      m_pBuffer->IncCharTick(-1);
      return;
    }
  }

  auto const pUndoStep = new DeleteUndoStep(this, lStart, lEnd);
  addUndoStep(pUndoStep);
}

void UndoStack::EndUndoGroup(const base::string16& pwszName) {
  if (m_eState == State_Disabled)
    return;

  if (m_pLast) {
    // Is empty block?
    if (m_pLast->is<BeginUndoStep>()) {
      delUndoStep(m_pLast);
      return;
    }
  }

  auto const pUndoStep = new EndUndoStep(pwszName);
  addUndoStep(pUndoStep);
}

void UndoStack::PushInsertText(Posn lStart, Posn lEnd) {
  DCHECK_LE(lStart, lEnd);

  if (lStart >= lEnd || m_eState == State_Disabled)
    return;

  // Merge insert UndoStep.
  if (m_pLast && m_pLast->is<InsertUndoStep>()) {
    auto const pLast = m_pLast->as<InsertUndoStep>();
    if (pLast->Merge(m_pBuffer, lStart, lEnd)) {
      m_pBuffer->IncCharTick(-1);
      return;
    }
  }

  auto const pUndoStep = new InsertUndoStep(lStart, lEnd);
  addUndoStep(pUndoStep);
}

Posn UndoStack::Redo(Posn lPosn, Count lCount) {
  if (!CanRedo())
    return -1;

  m_eState = State_Redo;

  int iDepth = 0;
  for (;;) {
    if (iDepth == 0) {
      if (lCount <= 0)
        break;
      --lCount;
    }

    if (!m_pRedo)
      break;

    auto const pRedo = m_pRedo;
    auto const pUndo = m_pUndo;

    if (pRedo == m_pUndo) {
      // We don't have no redo UndoStep.
      break;
    }

    // Are we are at redo point? If not, we don't execute.
    if (!lCount && !iDepth) {
      auto const lRedo = pRedo->GetBeforeRedo();
      if (lPosn != lRedo) {
        lPosn = lRedo;
        break;
      }
    }

    if (pRedo->is<BeginUndoStep>())
      ++iDepth;
    else if (pRedo->is<EndUndoStep>())
      --iDepth;

    pRedo->Redo(m_pBuffer);
    lPosn = pRedo->GetAfterRedo();
    m_pRedo = pRedo->m_pPrev;
    m_pUndo = pUndo != nullptr ? pUndo->m_pNext : m_pFirst;
  }
  return lPosn;
}

Posn UndoStack::Undo(Posn lPosn, Count lCount) {
  if (!CanUndo())
    return -1;

  if (m_eState == State_Redo) {
    // Truncate edit log betwee redo.next to last.
    CheckPoint();
  }

  if (m_eState != State_Undo)
    m_pUndo = m_pLast;

  m_eState = State_Undo;

  int iDepth = 0;
  for (;;) {
    if (!iDepth) {
      if (lCount <= 0)
        break;
      --lCount;
    }

    auto const pUndoStep = m_pUndo;
    if (!pUndoStep) {
      DCHECK(!iDepth);
      break;
    }

    if (!lCount && !iDepth) {
      auto const lUndo = pUndoStep->GetBeforeUndo();
      if (lPosn != lUndo) {
        lPosn = lUndo;
        break;
      }
    }

    if (pUndoStep->is<BeginUndoStep>())
      --iDepth;
    else if (pUndoStep->is<EndUndoStep>())
      ++iDepth;

    pUndoStep->Undo(m_pBuffer);
    lPosn = pUndoStep->GetAfterUndo();
    m_pUndo = pUndoStep->m_pPrev;
  }

  m_pRedo = m_pLast;
  return lPosn;
}


// BufferMutationObserver
void UndoStack::DidInsertAt(Posn offset, size_t length) {
  if (m_eState != State_Log)
    return;
  CheckPoint();
  PushInsertText(offset, static_cast<Posn>(offset + length));
}

void UndoStack::WillDeleteAt(Posn offset, size_t length) {
  if (m_eState != State_Log)
    return;
  CheckPoint();
  PushDeleteText(offset, static_cast<Posn>(offset + length));
}

//////////////////////////////////////////////////////////////////////
//
// UndoBlock
//
UndoBlock::~UndoBlock() {
  buffer_->EndUndoGroup(name_);
}

UndoBlock::UndoBlock(Buffer* buffer, const base::string16& name)
    : buffer_(buffer), name_(name) {
  buffer->StartUndoGroup(name);
}

void Buffer::EndUndoGroup(const base::string16& name) {
  undo_stack_->CheckPoint();
  undo_stack_->EndUndoGroup(name);
}

void Buffer::StartUndoGroup(const base::string16& name) {
  undo_stack_->CheckPoint();
  undo_stack_->BeginUndoGroup(name);
}

}  // namespace text
